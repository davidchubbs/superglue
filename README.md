Superglue
=========

[![Build](https://travis-ci.org/davidchubbs/superglue.png)](https://travis-ci.org/davidchubbs/superglue)

No dependencies.


Description
-----------

Superglue is interested in the organization of your application by promoting loosely coupled components and defining the order of their execution&mdash;or, *application flow*. It is inspired by a few different design patterns and attempts to consolidate some of their benefits. To understand better, see the examples below :)


Installation
------------

Install superglue:

```bash
npm install superglue
```


Documentation
-------------

Superglue *Publishers* are for triggering a **sequence of tasks**, while *Subscribers* are for registering logic to handle that task.

```js
superglue.subscribe("task1").then(function () { /* fired 1st */ });
superglue.subscribe("task2").then(function () { /* fired 2nd */ });

superglue.publish("task1", "task2");
```

Publishers can also fire their own logic at any time during the sequence of tasks.

```js
superglue.publish()
  .events("task1", "task2")
  .then(function () { ... })
  .event("task3");
```

Superglue also allows Publishers to define the *context*, which is then accessible to every Subscriber via `this`. This means updating the context will update the context for subsequent tasks.

```js
superglue.subscribe("build-name").then(function () {
  this.name = this.first + " " + this.last;
});

superglue.publish()
  .context({ first: "Julie", last: "Chubbs" })
  .event("build-name")
  .then(function () {
    console.log(this.name);
  });
//=> "Julie Chubbs"
```

Sometimes you will only want to trigger subscriber logic if the context has a certain state. You can do this using the `.filter()` method.

```js
superglue.subscribe("build-name")
  .filter(function () {
    return typeof this.first === "string" && typeof this.last === "string";
  })
  .then( /* only triggered if .filter returns true */ );
```

Other times, triggering the subscriber logic will be mandatory but the logic may still depend on the context having a certain state. To require a particular state, use the `.require()` method.

```js
superglue.subscribe("build-name")
  .require(function () {
    return typeof this.first === "string" && typeof this.last === "string";
  })
  .then( /* if .require returns false, a ContextError is triggered and this function is not invoked */ );
```

Superglue makes error handling useful by halting the sequence of tasks once an error occurs. Besides the `ContextError`s generated by `.require()` methods, you can also set errors by returning errors (`instanceof Error`) from your Subscriber or Publisher `.then()` methods, at which point, superglue will skip all remaining tasks. If you would like to catch and handle errors, pass in a function with the signature `function (err)` into your publisher's `.then()` method; currently, only Publishers can catch and handle errors (let me know if you desire it a different way).

```js
superglue.subscribe("task1").then(function () {
  return Error("here's what happened...");
});
superglue.subscribe("task2").then(function () {
  // never invoked
});

superglue.publish("task1", "task2")
  .then(function () { /* this one is skipped, since missing `err` argument */ })
  .then(function (err) {
    console.log(err.message);
  });
//=> here's what happened...
```

Lets look at a more useful example, building on top of **Express**. Notice the convention of namespacing tasks with the `:` character, which by doing so, allows you to use the `.tasks(namespace, [task1, ...])` method.

```js
superglue.subscribe("user:save:validate").then(function () {
  if (!this.body.first || !this.body.last) {
    return Error("First & last names are required");
  }
});
superglue.subscribe("user:save:db").then(function () {
  // add to db
});
superglue.subscribe("user:save:feedback").then(function () {
  this.feedback = this.body.name + " was created successfully!";
});

...

app.post("/user", function (req, res) {

  superglue.publish()
    .context(req)
    .tasks("user:save", ["validate", "db", "feedback"])
    .then(function (err) {
      if (err) {
        res.send(422, err.message);
      } else {
        res.send(this.feedback);
      }
    });

});
```

Superglue promotes decoupled, reusable components&mdash;keeping your code DRY. Even better, it becomes clearer what your application is actually doing by firing tasks with semantical names; for instance, in the example above we can see that we are using Express' `req` object as the context, then validating & saving the incoming data, and then providing feedback to the user. In essence, Superglue glues together your application components while providing a high-level view of how your application works.

While publishers define the flow of tasks fired, it can be useful to group tasks together on the subscriber side as well.

```js
superglue.group("user:save").tasks("user:save", ["validate", "db", "feedback"]);

...

app.post("/user", function (req, res) {

  superglue.publish()
    .context(req)
    // this fires "user:save:validate", "user:save:db", "user:save:feedback" for you
    .event("user:save")
    .then(...);

});
```

**More documentation of error handling coming soon**.


### Subscriber API

*Explain available methods & best practices.*


### Group-Subscriber API

*Explain available methods & best practices.*


### Publisher API

*Explain available methods & best practices.*


Feedback
--------

I would love feedback! Let me know what parts are confusing or what could be improved. Easiest way to discuss it is to submit an issue :)


License
-------

[The MIT License](http://opensource.org/licenses/MIT)

Copyright (c) 2014 David Chubbuck